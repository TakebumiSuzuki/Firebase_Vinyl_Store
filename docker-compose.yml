name: firebase_practice_app
services:
  frontend:
    build: ./frontend
    ports:
      - "5173:5173"
    volumes:
      # バインドの基本動作は、コンテナが起動するとき、コンテナ内の/frontendというパスには、
      # ホストPCの./frontendディレクトリの中身をそのまま映し出す（マウントする)というもの。
      - ./frontend:/frontend

      # flask側では、.venvを使わずシステムにパッケージをインストールしているので、この問題は起こらない。
      # 初回起動時、イメージの中にある /frontend/node_modules の中身を、frontend_node_modules
      # ボリュームにコピーする。そして、それをコンテナの /frontend/node_modules にマウントする。
      # 一度データがコピーされた後は、frontend_node_modulesボリュームが、コンテナ内の
      # /frontend/node_modulesの場所を「覆いかぶさる」状態になる。
      # 結局最初に名前付きボリュームにコピーされた node_module 固定となる。更新が必要なときには
      # docker-compose exec frontend npm installを行う
      - frontend_node_modules:/frontend/node_modules
    depends_on:
      - backend

  backend:
    build: ./backend
    ports:
      - "5000:5000"
    volumes:
      - ./backend:/backend
    # pg_isready コマンドが成功を返してから backend が起動開始
    depends_on:
      db:
        condition: service_healthy
    #　この記述があればdotenvは必要ないとのこと。つまり、環境変数はos.getenv() で直接取得可能
    env_file:
      - ./backend/.env


  db:
    # alpine で全く問題ありません。わざわざ bullseye を使う必要はほとんどありません
    image: postgres:17.5-alpine3.20
    volumes:
      - postgres_data:/var/lib/postgresql/data/

    # データベースを初期化するための環境変数
    # これらの値は、backend/.env 内のDATABASE_URLと一致させる必要がある
    env_file:
      - ./backend/.env

    # (任意) デバッグ用にホストPCからDBに接続したい場合
    ports:
      - "5433:5432"

    healthcheck:
      # ${変数名:-デフォルト値}: 環境変数が未定義または空の場合、デフォルト値を使用
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER:-postgres} -d ${POSTGRES_DB:-mydatabase}"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 30s

# 特定のパスではなく、Dockerエンジンが管理するpostgres_dataと名付けられた専用の領域にデータの実体が保存される
volumes:
  postgres_data:
  # これはnpmによる仮想環境のモジュールファイルをバリュームで隠されないようにするため
  frontend_node_modules: